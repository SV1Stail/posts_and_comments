package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.50

import (
	"context"
	"fmt"

	"github.com/SV1Stail/test_ozon/db"
	"github.com/SV1Stail/test_ozon/graph/model"
	"github.com/google/uuid"
	pgx "github.com/jackc/pgx/v4"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, allowComments bool, authorID string) (*model.Post, error) {
	if title == "" {
		return nil, fmt.Errorf("title cannot be empty")
	}
	if content == "" {
		return nil, fmt.Errorf("content cannot be empty")
	}
	if authorID == "" {
		return nil, fmt.Errorf("authorID cannot be empty")
	}
	pool := db.GetPool()

	tx, err := pool.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to start transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	postID := uuid.New().String()
	_, err = tx.Exec(ctx, "INSERT INTO posts (id, title, content, allow_comments, user_id) VALUES ($1, $2, $3, $4, $5)",
		postID, title, content, allowComments, authorID)
	if err != nil {
		return nil, fmt.Errorf("failed to insert post: %w", err)

	}
	err = tx.Commit(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	post := &model.Post{
		ID:            postID,
		Title:         title,
		Content:       content,
		AllowComments: allowComments,
		Author:        &model.User{ID: authorID},
	}
	return post, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, postID string, parentID *string, text string, authorID string) (*model.Comment, error) {
	if len(text) > 2000 {
		return nil, fmt.Errorf("comment text exceeds 2000 characters")
	}
	if postID == "" {
		return nil, fmt.Errorf("postID cannot be empty")
	}
	if text == "" {
		return nil, fmt.Errorf("text cannot be empty")
	}
	if authorID == "" {
		return nil, fmt.Errorf("authorID cannot be empty")
	}
	pool := db.GetPool()
	tx, err := pool.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to start transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	var postExists bool
	err = tx.QueryRow(ctx, "SELECT EXISTS(SELECT 1 FROM posts WHERE id=$1)", postID).Scan(&postExists)
	if err != nil {
		return nil, fmt.Errorf("failed to check if post exists: %w", err)
	}
	if !postExists {
		return nil, fmt.Errorf("post with id %s does not exist", postID)
	}
	if parentID != nil {
		var parentCommentExists bool
		err = tx.QueryRow(ctx, "SELECT EXISTS(SELECT 1 FROM comments WHERE id=$1)", parentID).Scan(&parentCommentExists)
		if err != nil {
			return nil, fmt.Errorf("failed to check if parent comment exists: %w", err)
		}
		if !parentCommentExists {
			return nil, fmt.Errorf("parent comment with id %s does not exist", postID)
		}
	}
	commentID := uuid.New().String()
	_, err = tx.Exec(ctx,
		"INSERT INTO comments (id, text, post_id, parent_id, user_id)VALUES ($1, $2, $3, $4, $5)",
		commentID, text, postID, parentID, authorID)
	if err != nil {
		return nil, err
	}
	err = tx.Commit(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}
	comment := &model.Comment{
		ID:       commentID,
		Text:     text,
		PostID:   postID,
		ParentID: parentID,
		Children: []*model.Comment{},
		Author:   &model.User{ID: authorID},
	}
	r.mu.Lock()
	if subs, ok := r.subscribers[postID]; ok {
		for _, sub := range subs {
			sub <- comment
		}
	}
	r.mu.Unlock()
	return comment, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	pool := db.GetPool()
	conn, err := pool.Acquire(ctx)
	if err != nil {
		return nil, err
	}
	defer conn.Release()

	rows, err := conn.Query(ctx, "SELECT id, title, content, allow_comments, user_id FROM posts")
	if err != nil {
		return nil, fmt.Errorf("failed to fetch posts: %w", err)

	}
	defer rows.Close()
	var posts []*model.Post
	postMap := make(map[string]*model.Post)

	for rows.Next() {
		var post model.Post
		var user model.User
		err := rows.Scan(&post.ID, &post.Title, &post.Content,
			&post.AllowComments, &user.ID)
		if err != nil {
			return nil, fmt.Errorf("failed to scan post: %w", err)
		}
		post.Author = &user

		post.Comments = []*model.Comment{}

		posts = append(posts, &post)
		postMap[post.ID] = &post
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows iteration error: %w", err)
	}
	comments, err := commentsForPosts(conn, ctx)
	if err != nil {
		return nil, err
	}

	for _, comment := range comments {
		if post, ok := postMap[comment.PostID]; ok {
			post.Comments = append(post.Comments, comment)
		}
	}

	return posts, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	pool := db.GetPool()
	conn, err := pool.Acquire(ctx)
	if err != nil {
		return nil, err
	}
	defer conn.Release()

	var postExists bool
	err = conn.QueryRow(ctx, "SELECT EXISTS(SELECT 1 FROM posts WHERE id=$1)", id).Scan(&postExists)
	if err != nil {
		return nil, fmt.Errorf("failed to check if post exists: %w", err)
	}
	if !postExists {
		return nil, fmt.Errorf("post with id %s does not exist", id)
	}

	row := conn.QueryRow(ctx, "SELECT id, title, content, allow_comments, user_id FROM posts WHERE id=$1", id)

	post := &model.Post{}
	author := &model.User{}
	post.Author = author
	err = row.Scan(&post.ID, &post.Title, &post.Content,
		&post.AllowComments, &author.ID)
	if err == pgx.ErrNoRows {
		return nil, fmt.Errorf("post not found")
	} else if err != nil {
		return nil, err
	}
	comments, err := commentsForPost(conn, ctx, post.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get comments: %w", err)
	}
	post.Comments = comments

	return post, nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(ctx context.Context, postID string, limit *int, offset *int) ([]*model.Comment, error) {
	pool := db.GetPool()
	conn, err := pool.Acquire(ctx)
	if err != nil {
		return nil, err
	}
	defer conn.Release()

	lim := 2
	if limit != nil && *limit >= 0 {
		lim = *limit
	}
	offs := 0
	if offset != nil && *offset > 0 {
		offs = *offset
	}

	comments, err := commentsGetChildrenForComment(conn, ctx, postID, lim, offs)
	if err != nil {
		return nil, fmt.Errorf("failed to get comments: %w", err)
	}
	return comments, nil
}

// CommentAdded is the resolver for the commentAdded field.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *model.Comment, error) {
	commentChan := make(chan *model.Comment)
	go func() {
		<-ctx.Done()
		close(commentChan)
	}()

	r.mu.Lock()
	if r.subscribers[postID] == nil {
		r.subscribers[postID] = make([]chan *model.Comment, 0)
	}
	r.subscribers[postID] = append(r.subscribers[postID], commentChan)
	r.mu.Unlock()

	return commentChan, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
